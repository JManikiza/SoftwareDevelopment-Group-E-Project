{"ast":null,"code":"'use strict';\n\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nexports.basename = basename;\nexports.dirname = dirname;\nexports.extname = extname;\nexports.join = join;\nexports.sep = '/';\nfunction basename(path, ext) {\n  var start = 0;\n  var end = -1;\n  var index;\n  var firstNonSlashEnd;\n  var seenNonSlash;\n  var extIndex;\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n  assertPath(path);\n  index = path.length;\n  if (ext === undefined || !ext.length || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1;\n          break;\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true;\n        end = index + 1;\n      }\n    }\n    return end < 0 ? '' : path.slice(start, end);\n  }\n  if (ext === path) {\n    return '';\n  }\n  firstNonSlashEnd = -1;\n  extIndex = ext.length - 1;\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1;\n        break;\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true;\n        firstNonSlashEnd = index + 1;\n      }\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index;\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1;\n          end = firstNonSlashEnd;\n        }\n      }\n    }\n  }\n  if (start === end) {\n    end = firstNonSlashEnd;\n  } else if (end < 0) {\n    end = path.length;\n  }\n  return path.slice(start, end);\n}\nfunction dirname(path) {\n  var end;\n  var unmatchedSlash;\n  var index;\n  assertPath(path);\n  if (!path.length) {\n    return '.';\n  }\n  end = -1;\n  index = path.length;\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index;\n        break;\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true;\n    }\n  }\n  return end < 0 ? path.charCodeAt(0) === 47 /* `/` */ ? '/' : '.' : end === 1 && path.charCodeAt(0) === 47 /* `/` */ ? '//' : path.slice(0, end);\n}\nfunction extname(path) {\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  var preDotState = 0;\n  var unmatchedSlash;\n  var code;\n  var index;\n  assertPath(path);\n  index = path.length;\n  while (index--) {\n    code = path.charCodeAt(index);\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1;\n        break;\n      }\n      continue;\n    }\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true;\n      end = index + 1;\n    }\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1;\n    }\n  }\n  if (startDot < 0 || end < 0 ||\n  // We saw a non-dot character immediately before the dot.\n  preDotState === 0 ||\n  // The (right-most) trimmed path component is exactly `..`.\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n}\nfunction join() {\n  var index = -1;\n  var joined;\n  while (++index < arguments.length) {\n    assertPath(arguments[index]);\n    if (arguments[index]) {\n      joined = joined === undefined ? arguments[index] : joined + '/' + arguments[index];\n    }\n  }\n  return joined === undefined ? '.' : normalize(joined);\n}\n\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  var absolute;\n  var value;\n  assertPath(path);\n  absolute = path.charCodeAt(0) === 47; /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  value = normalizeString(path, !absolute);\n  if (!value.length && !absolute) {\n    value = '.';\n  }\n  if (value.length && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/';\n  }\n  return absolute ? '/' + value : value;\n}\n\n// Resolve `.` and `..` elements in a path with directory names.\nfunction normalizeString(path, allowAboveRoot) {\n  var result = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var index = -1;\n  var code;\n  var lastSlashIndex;\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index);\n    } else if (code === 47 /* `/` */) {\n      break;\n    } else {\n      code = 47; /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 /* `.` */ || result.charCodeAt(result.length - 2) !== 46 /* `.` */) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/');\n\n            /* istanbul ignore else - No clue how to cover it. */\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = '';\n                lastSegmentLength = 0;\n              } else {\n                result = result.slice(0, lastSlashIndex);\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');\n              }\n              lastSlash = index;\n              dots = 0;\n              continue;\n            }\n          } else if (result.length) {\n            result = '';\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          result = result.length ? result + '/..' : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (result.length) {\n          result += '/' + path.slice(lastSlash + 1, index);\n        } else {\n          result = path.slice(lastSlash + 1, index);\n        }\n        lastSegmentLength = index - lastSlash - 1;\n      }\n      lastSlash = index;\n      dots = 0;\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++;\n    } else {\n      dots = -1;\n    }\n  }\n  return result;\n}\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}","map":{"version":3,"names":["exports","basename","dirname","extname","join","sep","path","ext","start","end","index","firstNonSlashEnd","seenNonSlash","extIndex","undefined","TypeError","assertPath","length","charCodeAt","slice","unmatchedSlash","startDot","startPart","preDotState","code","joined","arguments","normalize","absolute","value","normalizeString","allowAboveRoot","result","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","JSON","stringify"],"sources":["/Users/wallysonsilva/Documents/GitHub/SoftwareDevelopment-Group-E-Project/react-app/node_modules/vfile/lib/minpath.browser.js"],"sourcesContent":["'use strict'\n\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexports.basename = basename\nexports.dirname = dirname\nexports.extname = extname\nexports.join = join\nexports.sep = '/'\n\nfunction basename(path, ext) {\n  var start = 0\n  var end = -1\n  var index\n  var firstNonSlashEnd\n  var seenNonSlash\n  var extIndex\n\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  index = path.length\n\n  if (ext === undefined || !ext.length || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  firstNonSlashEnd = -1\n  extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\nfunction dirname(path) {\n  var end\n  var unmatchedSlash\n  var index\n\n  assertPath(path)\n\n  if (!path.length) {\n    return '.'\n  }\n\n  end = -1\n  index = path.length\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\nfunction extname(path) {\n  var startDot = -1\n  var startPart = 0\n  var end = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  var preDotState = 0\n  var unmatchedSlash\n  var code\n  var index\n\n  assertPath(path)\n\n  index = path.length\n\n  while (index--) {\n    code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\nfunction join() {\n  var index = -1\n  var joined\n\n  while (++index < arguments.length) {\n    assertPath(arguments[index])\n\n    if (arguments[index]) {\n      joined =\n        joined === undefined\n          ? arguments[index]\n          : joined + '/' + arguments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  var absolute\n  var value\n\n  assertPath(path)\n\n  absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  value = normalizeString(path, !absolute)\n\n  if (!value.length && !absolute) {\n    value = '.'\n  }\n\n  if (value.length && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n// Resolve `.` and `..` elements in a path with directory names.\nfunction normalizeString(path, allowAboveRoot) {\n  var result = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var index = -1\n  var code\n  var lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            /* istanbul ignore else - No clue how to cover it. */\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}