{"ast":null,"code":"'use strict';\n\nvar assign = require('../constant/assign.js');\nvar chunkedSplice = require('./chunked-splice.js');\nvar shallow = require('./shallow.js');\nfunction subtokenize(events) {\n  var jumps = {};\n  var index = -1;\n  var event;\n  var lineIndex;\n  var otherIndex;\n  var otherEvent;\n  var parameters;\n  var subevents;\n  var more;\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n    event = events[index]; // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (index && event[1].type === 'chunkFlow' && events[index - 1][1].type === 'listItemPrefix') {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'lineEndingBlank') {\n        otherIndex += 2;\n      }\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'content') {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break;\n          }\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1].isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    } // Enter.\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    } // Exit.\n    else if (event[1]._container || event[1]._movePreviousLineEndings) {\n      otherIndex = index;\n      lineIndex = undefined;\n      while (otherIndex--) {\n        otherEvent = events[otherIndex];\n        if (otherEvent[1].type === 'lineEnding' || otherEvent[1].type === 'lineEndingBlank') {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank';\n            }\n            otherEvent[1].type = 'lineEnding';\n            lineIndex = otherIndex;\n          }\n        } else {\n          break;\n        }\n      }\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = shallow(events[lineIndex][1].start); // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n  return !more;\n}\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1];\n  var context = events[eventIndex][2];\n  var startPosition = eventIndex - 1;\n  var startPositions = [];\n  var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n  var childEvents = tokenizer.events;\n  var jumps = [];\n  var gaps = {};\n  var stream;\n  var previous;\n  var index;\n  var entered;\n  var end;\n  var adjust; // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (token) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== token) {\n      // Empty.\n    }\n    startPositions.push(startPosition);\n    if (!token._tokenizer) {\n      stream = context.sliceStream(token);\n      if (!token.next) {\n        stream.push(null);\n      }\n      if (previous) {\n        tokenizer.defineSkip(token.start);\n      }\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n      tokenizer.write(stream);\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    } // Unravel the next token.\n\n    previous = token;\n    token = token.next;\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n  token = previous;\n  index = childEvents.length;\n  while (index--) {\n    // Make sure we’ve at least seen something (final eol is part of the last\n    // token).\n    if (childEvents[index][0] === 'enter') {\n      entered = true;\n    } else if (\n    // Find a void token that includes a break.\n    entered && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      add(childEvents.slice(index + 1, end));\n      // Help GC.\n      token._tokenizer = token.next = undefined;\n      token = token.previous;\n      end = index + 1;\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = token._tokenizer = token.next = undefined; // Do head:\n\n  add(childEvents.slice(0, end));\n  index = -1;\n  adjust = 0;\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n  return gaps;\n  function add(slice) {\n    var start = startPositions.pop();\n    jumps.unshift([start, start + slice.length - 1]);\n    chunkedSplice(events, start, 2, slice);\n  }\n}\nmodule.exports = subtokenize;","map":{"version":3,"names":["assign","require","chunkedSplice","shallow","subtokenize","events","jumps","index","event","lineIndex","otherIndex","otherEvent","parameters","subevents","more","length","type","_tokenizer","isInFirstContentOfListItem","contentType","subcontent","_container","_movePreviousLineEndings","undefined","end","start","slice","unshift","eventIndex","token","context","startPosition","startPositions","tokenizer","parser","childEvents","gaps","stream","previous","entered","adjust","push","sliceStream","next","defineSkip","_gfmTasklistFirstContentOfListItem","write","line","add","pop","module","exports"],"sources":["C:/Users/JMani/Documents/GitHub/SoftwareDevelopment-Group-E-Project/react-app/node_modules/micromark/dist/util/subtokenize.js"],"sourcesContent":["'use strict'\r\n\r\nvar assign = require('../constant/assign.js')\r\nvar chunkedSplice = require('./chunked-splice.js')\r\nvar shallow = require('./shallow.js')\r\n\r\nfunction subtokenize(events) {\r\n  var jumps = {}\r\n  var index = -1\r\n  var event\r\n  var lineIndex\r\n  var otherIndex\r\n  var otherEvent\r\n  var parameters\r\n  var subevents\r\n  var more\r\n\r\n  while (++index < events.length) {\r\n    while (index in jumps) {\r\n      index = jumps[index]\r\n    }\r\n\r\n    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\r\n    // is in the first content of a list item.\r\n\r\n    if (\r\n      index &&\r\n      event[1].type === 'chunkFlow' &&\r\n      events[index - 1][1].type === 'listItemPrefix'\r\n    ) {\r\n      subevents = event[1]._tokenizer.events\r\n      otherIndex = 0\r\n\r\n      if (\r\n        otherIndex < subevents.length &&\r\n        subevents[otherIndex][1].type === 'lineEndingBlank'\r\n      ) {\r\n        otherIndex += 2\r\n      }\r\n\r\n      if (\r\n        otherIndex < subevents.length &&\r\n        subevents[otherIndex][1].type === 'content'\r\n      ) {\r\n        while (++otherIndex < subevents.length) {\r\n          if (subevents[otherIndex][1].type === 'content') {\r\n            break\r\n          }\r\n\r\n          if (subevents[otherIndex][1].type === 'chunkText') {\r\n            subevents[otherIndex][1].isInFirstContentOfListItem = true\r\n            otherIndex++\r\n          }\r\n        }\r\n      }\r\n    } // Enter.\r\n\r\n    if (event[0] === 'enter') {\r\n      if (event[1].contentType) {\r\n        assign(jumps, subcontent(events, index))\r\n        index = jumps[index]\r\n        more = true\r\n      }\r\n    } // Exit.\r\n    else if (event[1]._container || event[1]._movePreviousLineEndings) {\r\n      otherIndex = index\r\n      lineIndex = undefined\r\n\r\n      while (otherIndex--) {\r\n        otherEvent = events[otherIndex]\r\n\r\n        if (\r\n          otherEvent[1].type === 'lineEnding' ||\r\n          otherEvent[1].type === 'lineEndingBlank'\r\n        ) {\r\n          if (otherEvent[0] === 'enter') {\r\n            if (lineIndex) {\r\n              events[lineIndex][1].type = 'lineEndingBlank'\r\n            }\r\n\r\n            otherEvent[1].type = 'lineEnding'\r\n            lineIndex = otherIndex\r\n          }\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n\r\n      if (lineIndex) {\r\n        // Fix position.\r\n        event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.\r\n\r\n        parameters = events.slice(lineIndex, index)\r\n        parameters.unshift(event)\r\n        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)\r\n      }\r\n    }\r\n  }\r\n\r\n  return !more\r\n}\r\n\r\nfunction subcontent(events, eventIndex) {\r\n  var token = events[eventIndex][1]\r\n  var context = events[eventIndex][2]\r\n  var startPosition = eventIndex - 1\r\n  var startPositions = []\r\n  var tokenizer =\r\n    token._tokenizer || context.parser[token.contentType](token.start)\r\n  var childEvents = tokenizer.events\r\n  var jumps = []\r\n  var gaps = {}\r\n  var stream\r\n  var previous\r\n  var index\r\n  var entered\r\n  var end\r\n  var adjust // Loop forward through the linked tokens to pass them in order to the\r\n  // subtokenizer.\r\n\r\n  while (token) {\r\n    // Find the position of the event for this token.\r\n    while (events[++startPosition][1] !== token) {\r\n      // Empty.\r\n    }\r\n\r\n    startPositions.push(startPosition)\r\n\r\n    if (!token._tokenizer) {\r\n      stream = context.sliceStream(token)\r\n\r\n      if (!token.next) {\r\n        stream.push(null)\r\n      }\r\n\r\n      if (previous) {\r\n        tokenizer.defineSkip(token.start)\r\n      }\r\n\r\n      if (token.isInFirstContentOfListItem) {\r\n        tokenizer._gfmTasklistFirstContentOfListItem = true\r\n      }\r\n\r\n      tokenizer.write(stream)\r\n\r\n      if (token.isInFirstContentOfListItem) {\r\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\r\n      }\r\n    } // Unravel the next token.\r\n\r\n    previous = token\r\n    token = token.next\r\n  } // Now, loop back through all events (and linked tokens), to figure out which\r\n  // parts belong where.\r\n\r\n  token = previous\r\n  index = childEvents.length\r\n\r\n  while (index--) {\r\n    // Make sure we’ve at least seen something (final eol is part of the last\r\n    // token).\r\n    if (childEvents[index][0] === 'enter') {\r\n      entered = true\r\n    } else if (\r\n      // Find a void token that includes a break.\r\n      entered &&\r\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\r\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\r\n    ) {\r\n      add(childEvents.slice(index + 1, end))\r\n      // Help GC.\r\n      token._tokenizer = token.next = undefined\r\n      token = token.previous\r\n      end = index + 1\r\n    }\r\n  }\r\n\r\n  // Help GC.\r\n  tokenizer.events = token._tokenizer = token.next = undefined // Do head:\r\n\r\n  add(childEvents.slice(0, end))\r\n  index = -1\r\n  adjust = 0\r\n\r\n  while (++index < jumps.length) {\r\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\r\n    adjust += jumps[index][1] - jumps[index][0] - 1\r\n  }\r\n\r\n  return gaps\r\n\r\n  function add(slice) {\r\n    var start = startPositions.pop()\r\n    jumps.unshift([start, start + slice.length - 1])\r\n    chunkedSplice(events, start, 2, slice)\r\n  }\r\n}\r\n\r\nmodule.exports = subtokenize\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}