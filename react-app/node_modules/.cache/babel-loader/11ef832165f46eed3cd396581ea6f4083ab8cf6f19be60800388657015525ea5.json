{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar assign = require('../constant/assign.js');\nvar shallow = require('../util/shallow.js');\nvar text = initializeFactory('text');\nvar string = initializeFactory('string');\nvar resolver = {\n  resolveAll: createResolver()\n};\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined)\n  };\n  function initializeText(effects) {\n    var self = this;\n    var constructs = this.parser.constructs[field];\n    var text = effects.attempt(constructs, start, notText);\n    return start;\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n      effects.enter('data');\n      effects.consume(code);\n      return data;\n    }\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data');\n        return text(code);\n      } // Data.\n\n      effects.consume(code);\n      return data;\n    }\n    function atBreak(code) {\n      var list = constructs[code];\n      var index = -1;\n      if (code === null) {\n        return true;\n      }\n      if (list) {\n        while (++index < list.length) {\n          if (!list[index].previous || list[index].previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n}\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n  function resolveAllText(events, context) {\n    var index = -1;\n    var enter; // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n        enter = undefined;\n      }\n    }\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n} // A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we can’t hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1;\n  var chunks;\n  var data;\n  var chunk;\n  var index;\n  var bufferIndex;\n  var size;\n  var tabs;\n  var token;\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') && events[eventIndex - 1][1].type === 'data') {\n      data = events[eventIndex - 1][1];\n      chunks = context.sliceStream(data);\n      index = chunks.length;\n      bufferIndex = -1;\n      size = 0;\n      tabs = undefined;\n      while (index--) {\n        chunk = chunks[index];\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        } // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) ;else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n      if (size) {\n        token = {\n          type: eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex\n          },\n          end: shallow(data.end)\n        };\n        data.end = shallow(token.start);\n        if (data.start.offset === data.end.offset) {\n          assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n      eventIndex++;\n    }\n  }\n  return events;\n}\nexports.resolver = resolver;\nexports.string = string;\nexports.text = text;","map":{"version":3,"names":["Object","defineProperty","exports","value","assign","require","shallow","text","initializeFactory","string","resolver","resolveAll","createResolver","field","tokenize","initializeText","resolveAllLineSuffixes","undefined","effects","self","constructs","parser","attempt","start","notText","code","atBreak","consume","enter","data","exit","list","index","length","previous","call","extraResolver","resolveAllText","events","context","type","end","splice","eventIndex","chunks","chunk","bufferIndex","size","tabs","token","sliceStream","charCodeAt","line","column","offset","_index","_bufferIndex"],"sources":["C:/Users/wally/Documents/GitHub/SoftwareDevelopment-Group-E-Project/react-app/node_modules/micromark/dist/initialize/text.js"],"sourcesContent":["'use strict'\r\n\r\nObject.defineProperty(exports, '__esModule', {value: true})\r\n\r\nvar assign = require('../constant/assign.js')\r\nvar shallow = require('../util/shallow.js')\r\n\r\nvar text = initializeFactory('text')\r\nvar string = initializeFactory('string')\r\nvar resolver = {\r\n  resolveAll: createResolver()\r\n}\r\n\r\nfunction initializeFactory(field) {\r\n  return {\r\n    tokenize: initializeText,\r\n    resolveAll: createResolver(\r\n      field === 'text' ? resolveAllLineSuffixes : undefined\r\n    )\r\n  }\r\n\r\n  function initializeText(effects) {\r\n    var self = this\r\n    var constructs = this.parser.constructs[field]\r\n    var text = effects.attempt(constructs, start, notText)\r\n    return start\r\n\r\n    function start(code) {\r\n      return atBreak(code) ? text(code) : notText(code)\r\n    }\r\n\r\n    function notText(code) {\r\n      if (code === null) {\r\n        effects.consume(code)\r\n        return\r\n      }\r\n\r\n      effects.enter('data')\r\n      effects.consume(code)\r\n      return data\r\n    }\r\n\r\n    function data(code) {\r\n      if (atBreak(code)) {\r\n        effects.exit('data')\r\n        return text(code)\r\n      } // Data.\r\n\r\n      effects.consume(code)\r\n      return data\r\n    }\r\n\r\n    function atBreak(code) {\r\n      var list = constructs[code]\r\n      var index = -1\r\n\r\n      if (code === null) {\r\n        return true\r\n      }\r\n\r\n      if (list) {\r\n        while (++index < list.length) {\r\n          if (\r\n            !list[index].previous ||\r\n            list[index].previous.call(self, self.previous)\r\n          ) {\r\n            return true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createResolver(extraResolver) {\r\n  return resolveAllText\r\n\r\n  function resolveAllText(events, context) {\r\n    var index = -1\r\n    var enter // A rather boring computation (to merge adjacent `data` events) which\r\n    // improves mm performance by 29%.\r\n\r\n    while (++index <= events.length) {\r\n      if (enter === undefined) {\r\n        if (events[index] && events[index][1].type === 'data') {\r\n          enter = index\r\n          index++\r\n        }\r\n      } else if (!events[index] || events[index][1].type !== 'data') {\r\n        // Don’t do anything if there is one data token.\r\n        if (index !== enter + 2) {\r\n          events[enter][1].end = events[index - 1][1].end\r\n          events.splice(enter + 2, index - enter - 2)\r\n          index = enter + 2\r\n        }\r\n\r\n        enter = undefined\r\n      }\r\n    }\r\n\r\n    return extraResolver ? extraResolver(events, context) : events\r\n  }\r\n} // A rather ugly set of instructions which again looks at chunks in the input\r\n// stream.\r\n// The reason to do this here is that it is *much* faster to parse in reverse.\r\n// And that we can’t hook into `null` to split the line suffix before an EOF.\r\n// To do: figure out if we can make this into a clean utility, or even in core.\r\n// As it will be useful for GFMs literal autolink extension (and maybe even\r\n// tables?)\r\n\r\nfunction resolveAllLineSuffixes(events, context) {\r\n  var eventIndex = -1\r\n  var chunks\r\n  var data\r\n  var chunk\r\n  var index\r\n  var bufferIndex\r\n  var size\r\n  var tabs\r\n  var token\r\n\r\n  while (++eventIndex <= events.length) {\r\n    if (\r\n      (eventIndex === events.length ||\r\n        events[eventIndex][1].type === 'lineEnding') &&\r\n      events[eventIndex - 1][1].type === 'data'\r\n    ) {\r\n      data = events[eventIndex - 1][1]\r\n      chunks = context.sliceStream(data)\r\n      index = chunks.length\r\n      bufferIndex = -1\r\n      size = 0\r\n      tabs = undefined\r\n\r\n      while (index--) {\r\n        chunk = chunks[index]\r\n\r\n        if (typeof chunk === 'string') {\r\n          bufferIndex = chunk.length\r\n\r\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\r\n            size++\r\n            bufferIndex--\r\n          }\r\n\r\n          if (bufferIndex) break\r\n          bufferIndex = -1\r\n        } // Number\r\n        else if (chunk === -2) {\r\n          tabs = true\r\n          size++\r\n        } else if (chunk === -1);\r\n        else {\r\n          // Replacement character, exit.\r\n          index++\r\n          break\r\n        }\r\n      }\r\n\r\n      if (size) {\r\n        token = {\r\n          type:\r\n            eventIndex === events.length || tabs || size < 2\r\n              ? 'lineSuffix'\r\n              : 'hardBreakTrailing',\r\n          start: {\r\n            line: data.end.line,\r\n            column: data.end.column - size,\r\n            offset: data.end.offset - size,\r\n            _index: data.start._index + index,\r\n            _bufferIndex: index\r\n              ? bufferIndex\r\n              : data.start._bufferIndex + bufferIndex\r\n          },\r\n          end: shallow(data.end)\r\n        }\r\n        data.end = shallow(token.start)\r\n\r\n        if (data.start.offset === data.end.offset) {\r\n          assign(data, token)\r\n        } else {\r\n          events.splice(\r\n            eventIndex,\r\n            0,\r\n            ['enter', token, context],\r\n            ['exit', token, context]\r\n          )\r\n          eventIndex += 2\r\n        }\r\n      }\r\n\r\n      eventIndex++\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\nexports.resolver = resolver\r\nexports.string = string\r\nexports.text = text\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}