{"ast":null,"code":"'use strict';\n\nvar assign = require('../constant/assign.js');\nvar markdownLineEnding = require('../character/markdown-line-ending.js');\nvar chunkedPush = require('./chunked-push.js');\nvar chunkedSplice = require('./chunked-splice.js');\nvar miniflat = require('./miniflat.js');\nvar resolveAll = require('./resolve-all.js');\nvar serializeChunks = require('./serialize-chunks.js');\nvar shallow = require('./shallow.js');\nvar sliceChunks = require('./slice-chunks.js');\n\n// Create a tokenizer.\n// Tokenizers deal with one type of data (e.g., containers, flow, text).\n// The parser is the object dealing with it all.\n// `initialize` works like other constructs, except that only its `tokenize`\n// function is used, in which case it doesn’t receive an `ok` or `nok`.\n// `from` can be given to set the point before the first character, although\n// when further lines are indented, they must be set with `defineSkip`.\nfunction createTokenizer(parser, initialize, from) {\n  var point = from ? shallow(from) : {\n    line: 1,\n    column: 1,\n    offset: 0\n  };\n  var columnStart = {};\n  var resolveAllConstructs = [];\n  var chunks = [];\n  var stack = [];\n  var effects = {\n    consume: consume,\n    enter: enter,\n    exit: exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    }),\n    lazy: constructFactory(onsuccessfulcheck, {\n      lazy: true\n    })\n  }; // State and tools for resolving and serializing.\n\n  var context = {\n    previous: null,\n    events: [],\n    parser: parser,\n    sliceStream: sliceStream,\n    sliceSerialize: sliceSerialize,\n    now: now,\n    defineSkip: skip,\n    write: write\n  }; // The state function.\n\n  var state = initialize.tokenize.call(context, effects); // Track which character we expect to be consumed, to catch bugs.\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize);\n  } // Store where we are in the input stream.\n\n  point._index = 0;\n  point._bufferIndex = -1;\n  return context;\n  function write(slice) {\n    chunks = chunkedPush(chunks, slice);\n    main(); // Exit if we’re not done, resolve might change stuff.\n\n    if (chunks[chunks.length - 1] !== null) {\n      return [];\n    }\n    addResult(initialize, 0); // Otherwise, resolve, and exit.\n\n    context.events = resolveAll(resolveAllConstructs, context.events, context);\n    return context.events;\n  } //\n  // Tools.\n  //\n\n  function sliceSerialize(token) {\n    return serializeChunks(sliceStream(token));\n  }\n  function sliceStream(token) {\n    return sliceChunks(chunks, token);\n  }\n  function now() {\n    return shallow(point);\n  }\n  function skip(value) {\n    columnStart[value.line] = value.column;\n    accountForPotentialSkip();\n  } //\n  // State management.\n  //\n  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n  // `consume`).\n  // Here is where we walk through the chunks, which either include strings of\n  // several characters, or numerical character codes.\n  // The reason to do this in a loop instead of a call is so the stack can\n  // drain.\n\n  function main() {\n    var chunkIndex;\n    var chunk;\n    while (point._index < chunks.length) {\n      chunk = chunks[point._index]; // If we’re in a buffer chunk, loop through it.\n\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index;\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0;\n        }\n        while (point._index === chunkIndex && point._bufferIndex < chunk.length) {\n          go(chunk.charCodeAt(point._bufferIndex));\n        }\n      } else {\n        go(chunk);\n      }\n    }\n  } // Deal with one code.\n\n  function go(code) {\n    state = state(code);\n  } // Move a character forward.\n\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++;\n      point.column = 1;\n      point.offset += code === -3 ? 2 : 1;\n      accountForPotentialSkip();\n    } else if (code !== -1) {\n      point.column++;\n      point.offset++;\n    } // Not in a string chunk.\n\n    if (point._bufferIndex < 0) {\n      point._index++;\n    } else {\n      point._bufferIndex++; // At end of string chunk.\n\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1;\n        point._index++;\n      }\n    } // Expose the previous character.\n\n    context.previous = code; // Mark as consumed.\n  } // Start a token.\n\n  function enter(type, fields) {\n    var token = fields || {};\n    token.type = type;\n    token.start = now();\n    context.events.push(['enter', token, context]);\n    stack.push(token);\n    return token;\n  } // Stop a token.\n\n  function exit(type) {\n    var token = stack.pop();\n    token.end = now();\n    context.events.push(['exit', token, context]);\n    return token;\n  } // Use results.\n\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from);\n  } // Discard results.\n\n  function onsuccessfulcheck(construct, info) {\n    info.restore();\n  } // Factory to attempt/check/interrupt.\n\n  function constructFactory(onreturn, fields) {\n    return hook; // Handle either an object mapping codes to constructs, a list of\n    // constructs, or a single construct.\n\n    function hook(constructs, returnState, bogusState) {\n      var listOfConstructs;\n      var constructIndex;\n      var currentConstruct;\n      var info;\n      return constructs.tokenize || 'length' in constructs ? handleListOfConstructs(miniflat(constructs)) : handleMapOfConstructs;\n      function handleMapOfConstructs(code) {\n        if (code in constructs || null in constructs) {\n          return handleListOfConstructs(constructs.null ? /* c8 ignore next */\n          miniflat(constructs[code]).concat(miniflat(constructs.null)) : constructs[code])(code);\n        }\n        return bogusState(code);\n      }\n      function handleListOfConstructs(list) {\n        listOfConstructs = list;\n        constructIndex = 0;\n        return handleConstruct(list[constructIndex]);\n      }\n      function handleConstruct(construct) {\n        return start;\n        function start(code) {\n          // To do: not nede to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store();\n          currentConstruct = construct;\n          if (!construct.partial) {\n            context.currentConstruct = construct;\n          }\n          if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {\n            return nok();\n          }\n          return construct.tokenize.call(fields ? assign({}, context, fields) : context, effects, ok, nok)(code);\n        }\n      }\n      function ok(code) {\n        onreturn(currentConstruct, info);\n        return returnState;\n      }\n      function nok(code) {\n        info.restore();\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex]);\n        }\n        return bogusState;\n      }\n    }\n  }\n  function addResult(construct, from) {\n    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {\n      resolveAllConstructs.push(construct);\n    }\n    if (construct.resolve) {\n      chunkedSplice(context.events, from, context.events.length - from, construct.resolve(context.events.slice(from), context));\n    }\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context);\n    }\n  }\n  function store() {\n    var startPoint = now();\n    var startPrevious = context.previous;\n    var startCurrentConstruct = context.currentConstruct;\n    var startEventsIndex = context.events.length;\n    var startStack = Array.from(stack);\n    return {\n      restore: restore,\n      from: startEventsIndex\n    };\n    function restore() {\n      point = startPoint;\n      context.previous = startPrevious;\n      context.currentConstruct = startCurrentConstruct;\n      context.events.length = startEventsIndex;\n      stack = startStack;\n      accountForPotentialSkip();\n    }\n  }\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line];\n      point.offset += columnStart[point.line] - 1;\n    }\n  }\n}\nmodule.exports = createTokenizer;","map":{"version":3,"names":["assign","require","markdownLineEnding","chunkedPush","chunkedSplice","miniflat","resolveAll","serializeChunks","shallow","sliceChunks","createTokenizer","parser","initialize","from","point","line","column","offset","columnStart","resolveAllConstructs","chunks","stack","effects","consume","enter","exit","attempt","constructFactory","onsuccessfulconstruct","check","onsuccessfulcheck","interrupt","lazy","context","previous","events","sliceStream","sliceSerialize","now","defineSkip","skip","write","state","tokenize","call","push","_index","_bufferIndex","slice","main","length","addResult","token","value","accountForPotentialSkip","chunkIndex","chunk","go","charCodeAt","code","type","fields","start","pop","end","construct","info","restore","onreturn","hook","constructs","returnState","bogusState","listOfConstructs","constructIndex","currentConstruct","handleListOfConstructs","handleMapOfConstructs","null","concat","list","handleConstruct","store","partial","name","disable","indexOf","nok","ok","resolve","resolveTo","startPoint","startPrevious","startCurrentConstruct","startEventsIndex","startStack","Array","module","exports"],"sources":["C:/Users/wally/Documents/GitHub/SoftwareDevelopment-Group-E-Project/react-app/node_modules/micromark/dist/util/create-tokenizer.js"],"sourcesContent":["'use strict'\r\n\r\nvar assign = require('../constant/assign.js')\r\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\r\nvar chunkedPush = require('./chunked-push.js')\r\nvar chunkedSplice = require('./chunked-splice.js')\r\nvar miniflat = require('./miniflat.js')\r\nvar resolveAll = require('./resolve-all.js')\r\nvar serializeChunks = require('./serialize-chunks.js')\r\nvar shallow = require('./shallow.js')\r\nvar sliceChunks = require('./slice-chunks.js')\r\n\r\n// Create a tokenizer.\r\n// Tokenizers deal with one type of data (e.g., containers, flow, text).\r\n// The parser is the object dealing with it all.\r\n// `initialize` works like other constructs, except that only its `tokenize`\r\n// function is used, in which case it doesn’t receive an `ok` or `nok`.\r\n// `from` can be given to set the point before the first character, although\r\n// when further lines are indented, they must be set with `defineSkip`.\r\nfunction createTokenizer(parser, initialize, from) {\r\n  var point = from\r\n    ? shallow(from)\r\n    : {\r\n        line: 1,\r\n        column: 1,\r\n        offset: 0\r\n      }\r\n  var columnStart = {}\r\n  var resolveAllConstructs = []\r\n  var chunks = []\r\n  var stack = []\r\n\r\n  var effects = {\r\n    consume: consume,\r\n    enter: enter,\r\n    exit: exit,\r\n    attempt: constructFactory(onsuccessfulconstruct),\r\n    check: constructFactory(onsuccessfulcheck),\r\n    interrupt: constructFactory(onsuccessfulcheck, {\r\n      interrupt: true\r\n    }),\r\n    lazy: constructFactory(onsuccessfulcheck, {\r\n      lazy: true\r\n    })\r\n  } // State and tools for resolving and serializing.\r\n\r\n  var context = {\r\n    previous: null,\r\n    events: [],\r\n    parser: parser,\r\n    sliceStream: sliceStream,\r\n    sliceSerialize: sliceSerialize,\r\n    now: now,\r\n    defineSkip: skip,\r\n    write: write\r\n  } // The state function.\r\n\r\n  var state = initialize.tokenize.call(context, effects) // Track which character we expect to be consumed, to catch bugs.\r\n\r\n  if (initialize.resolveAll) {\r\n    resolveAllConstructs.push(initialize)\r\n  } // Store where we are in the input stream.\r\n\r\n  point._index = 0\r\n  point._bufferIndex = -1\r\n  return context\r\n\r\n  function write(slice) {\r\n    chunks = chunkedPush(chunks, slice)\r\n    main() // Exit if we’re not done, resolve might change stuff.\r\n\r\n    if (chunks[chunks.length - 1] !== null) {\r\n      return []\r\n    }\r\n\r\n    addResult(initialize, 0) // Otherwise, resolve, and exit.\r\n\r\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\r\n    return context.events\r\n  } //\r\n  // Tools.\r\n  //\r\n\r\n  function sliceSerialize(token) {\r\n    return serializeChunks(sliceStream(token))\r\n  }\r\n\r\n  function sliceStream(token) {\r\n    return sliceChunks(chunks, token)\r\n  }\r\n\r\n  function now() {\r\n    return shallow(point)\r\n  }\r\n\r\n  function skip(value) {\r\n    columnStart[value.line] = value.column\r\n    accountForPotentialSkip()\r\n  } //\r\n  // State management.\r\n  //\r\n  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\r\n  // `consume`).\r\n  // Here is where we walk through the chunks, which either include strings of\r\n  // several characters, or numerical character codes.\r\n  // The reason to do this in a loop instead of a call is so the stack can\r\n  // drain.\r\n\r\n  function main() {\r\n    var chunkIndex\r\n    var chunk\r\n\r\n    while (point._index < chunks.length) {\r\n      chunk = chunks[point._index] // If we’re in a buffer chunk, loop through it.\r\n\r\n      if (typeof chunk === 'string') {\r\n        chunkIndex = point._index\r\n\r\n        if (point._bufferIndex < 0) {\r\n          point._bufferIndex = 0\r\n        }\r\n\r\n        while (\r\n          point._index === chunkIndex &&\r\n          point._bufferIndex < chunk.length\r\n        ) {\r\n          go(chunk.charCodeAt(point._bufferIndex))\r\n        }\r\n      } else {\r\n        go(chunk)\r\n      }\r\n    }\r\n  } // Deal with one code.\r\n\r\n  function go(code) {\r\n    state = state(code)\r\n  } // Move a character forward.\r\n\r\n  function consume(code) {\r\n    if (markdownLineEnding(code)) {\r\n      point.line++\r\n      point.column = 1\r\n      point.offset += code === -3 ? 2 : 1\r\n      accountForPotentialSkip()\r\n    } else if (code !== -1) {\r\n      point.column++\r\n      point.offset++\r\n    } // Not in a string chunk.\r\n\r\n    if (point._bufferIndex < 0) {\r\n      point._index++\r\n    } else {\r\n      point._bufferIndex++ // At end of string chunk.\r\n\r\n      if (point._bufferIndex === chunks[point._index].length) {\r\n        point._bufferIndex = -1\r\n        point._index++\r\n      }\r\n    } // Expose the previous character.\r\n\r\n    context.previous = code // Mark as consumed.\r\n  } // Start a token.\r\n\r\n  function enter(type, fields) {\r\n    var token = fields || {}\r\n    token.type = type\r\n    token.start = now()\r\n    context.events.push(['enter', token, context])\r\n    stack.push(token)\r\n    return token\r\n  } // Stop a token.\r\n\r\n  function exit(type) {\r\n    var token = stack.pop()\r\n    token.end = now()\r\n    context.events.push(['exit', token, context])\r\n    return token\r\n  } // Use results.\r\n\r\n  function onsuccessfulconstruct(construct, info) {\r\n    addResult(construct, info.from)\r\n  } // Discard results.\r\n\r\n  function onsuccessfulcheck(construct, info) {\r\n    info.restore()\r\n  } // Factory to attempt/check/interrupt.\r\n\r\n  function constructFactory(onreturn, fields) {\r\n    return hook // Handle either an object mapping codes to constructs, a list of\r\n    // constructs, or a single construct.\r\n\r\n    function hook(constructs, returnState, bogusState) {\r\n      var listOfConstructs\r\n      var constructIndex\r\n      var currentConstruct\r\n      var info\r\n      return constructs.tokenize || 'length' in constructs\r\n        ? handleListOfConstructs(miniflat(constructs))\r\n        : handleMapOfConstructs\r\n\r\n      function handleMapOfConstructs(code) {\r\n        if (code in constructs || null in constructs) {\r\n          return handleListOfConstructs(\r\n            constructs.null\r\n              ? /* c8 ignore next */\r\n                miniflat(constructs[code]).concat(miniflat(constructs.null))\r\n              : constructs[code]\r\n          )(code)\r\n        }\r\n\r\n        return bogusState(code)\r\n      }\r\n\r\n      function handleListOfConstructs(list) {\r\n        listOfConstructs = list\r\n        constructIndex = 0\r\n        return handleConstruct(list[constructIndex])\r\n      }\r\n\r\n      function handleConstruct(construct) {\r\n        return start\r\n\r\n        function start(code) {\r\n          // To do: not nede to store if there is no bogus state, probably?\r\n          // Currently doesn’t work because `inspect` in document does a check\r\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\r\n          // by not storing.\r\n          info = store()\r\n          currentConstruct = construct\r\n\r\n          if (!construct.partial) {\r\n            context.currentConstruct = construct\r\n          }\r\n\r\n          if (\r\n            construct.name &&\r\n            context.parser.constructs.disable.null.indexOf(construct.name) > -1\r\n          ) {\r\n            return nok()\r\n          }\r\n\r\n          return construct.tokenize.call(\r\n            fields ? assign({}, context, fields) : context,\r\n            effects,\r\n            ok,\r\n            nok\r\n          )(code)\r\n        }\r\n      }\r\n\r\n      function ok(code) {\r\n        onreturn(currentConstruct, info)\r\n        return returnState\r\n      }\r\n\r\n      function nok(code) {\r\n        info.restore()\r\n\r\n        if (++constructIndex < listOfConstructs.length) {\r\n          return handleConstruct(listOfConstructs[constructIndex])\r\n        }\r\n\r\n        return bogusState\r\n      }\r\n    }\r\n  }\r\n\r\n  function addResult(construct, from) {\r\n    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {\r\n      resolveAllConstructs.push(construct)\r\n    }\r\n\r\n    if (construct.resolve) {\r\n      chunkedSplice(\r\n        context.events,\r\n        from,\r\n        context.events.length - from,\r\n        construct.resolve(context.events.slice(from), context)\r\n      )\r\n    }\r\n\r\n    if (construct.resolveTo) {\r\n      context.events = construct.resolveTo(context.events, context)\r\n    }\r\n  }\r\n\r\n  function store() {\r\n    var startPoint = now()\r\n    var startPrevious = context.previous\r\n    var startCurrentConstruct = context.currentConstruct\r\n    var startEventsIndex = context.events.length\r\n    var startStack = Array.from(stack)\r\n    return {\r\n      restore: restore,\r\n      from: startEventsIndex\r\n    }\r\n\r\n    function restore() {\r\n      point = startPoint\r\n      context.previous = startPrevious\r\n      context.currentConstruct = startCurrentConstruct\r\n      context.events.length = startEventsIndex\r\n      stack = startStack\r\n      accountForPotentialSkip()\r\n    }\r\n  }\r\n\r\n  function accountForPotentialSkip() {\r\n    if (point.line in columnStart && point.column < 2) {\r\n      point.column = columnStart[point.line]\r\n      point.offset += columnStart[point.line] - 1\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = createTokenizer\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}