{"ast":null,"code":"'use strict';\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js');\nvar codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous: previous\n};\nfunction resolveCodeText(events) {\n  var tailExitIndex = events.length - 4;\n  var headEnterIndex = 3;\n  var index;\n  var enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = events[headEnterIndex][1].type = 'codeTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'codeTextData';\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}\nfunction tokenizeCodeText(effects, ok, nok) {\n  var sizeOpen = 0;\n  var size;\n  var token;\n  return start;\n  function start(code) {\n    effects.enter('codeText');\n    effects.enter('codeTextSequence');\n    return openingSequence(code);\n  }\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code);\n      sizeOpen++;\n      return openingSequence;\n    }\n    effects.exit('codeTextSequence');\n    return gap(code);\n  }\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence');\n      size = 0;\n      return closingSequence(code);\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return gap;\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return gap;\n    } // Data.\n\n    effects.enter('codeTextData');\n    return data(code);\n  } // In code.\n\n  function data(code) {\n    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {\n      effects.exit('codeTextData');\n      return gap(code);\n    }\n    effects.consume(code);\n    return data;\n  } // Closing fence.\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code);\n      size++;\n      return closingSequence;\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence');\n      effects.exit('codeText');\n      return ok(code);\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData';\n    return data(code);\n  }\n}\nmodule.exports = codeText;","map":{"version":3,"names":["markdownLineEnding","require","codeText","name","tokenize","tokenizeCodeText","resolve","resolveCodeText","previous","events","tailExitIndex","length","headEnterIndex","index","enter","type","undefined","end","splice","code","effects","ok","nok","sizeOpen","size","token","start","openingSequence","consume","exit","gap","closingSequence","data","module","exports"],"sources":["C:/Users/wally/Documents/GitHub/SoftwareDevelopment-Group-E-Project/react-app/node_modules/micromark/dist/tokenize/code-text.js"],"sourcesContent":["'use strict'\r\n\r\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\r\n\r\nvar codeText = {\r\n  name: 'codeText',\r\n  tokenize: tokenizeCodeText,\r\n  resolve: resolveCodeText,\r\n  previous: previous\r\n}\r\n\r\nfunction resolveCodeText(events) {\r\n  var tailExitIndex = events.length - 4\r\n  var headEnterIndex = 3\r\n  var index\r\n  var enter // If we start and end with an EOL or a space.\r\n\r\n  if (\r\n    (events[headEnterIndex][1].type === 'lineEnding' ||\r\n      events[headEnterIndex][1].type === 'space') &&\r\n    (events[tailExitIndex][1].type === 'lineEnding' ||\r\n      events[tailExitIndex][1].type === 'space')\r\n  ) {\r\n    index = headEnterIndex // And we have data.\r\n\r\n    while (++index < tailExitIndex) {\r\n      if (events[index][1].type === 'codeTextData') {\r\n        // Then we have padding.\r\n        events[tailExitIndex][1].type = events[headEnterIndex][1].type =\r\n          'codeTextPadding'\r\n        headEnterIndex += 2\r\n        tailExitIndex -= 2\r\n        break\r\n      }\r\n    }\r\n  } // Merge adjacent spaces and data.\r\n\r\n  index = headEnterIndex - 1\r\n  tailExitIndex++\r\n\r\n  while (++index <= tailExitIndex) {\r\n    if (enter === undefined) {\r\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\r\n        enter = index\r\n      }\r\n    } else if (\r\n      index === tailExitIndex ||\r\n      events[index][1].type === 'lineEnding'\r\n    ) {\r\n      events[enter][1].type = 'codeTextData'\r\n\r\n      if (index !== enter + 2) {\r\n        events[enter][1].end = events[index - 1][1].end\r\n        events.splice(enter + 2, index - enter - 2)\r\n        tailExitIndex -= index - enter - 2\r\n        index = enter + 2\r\n      }\r\n\r\n      enter = undefined\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\nfunction previous(code) {\r\n  // If there is a previous code, there will always be a tail.\r\n  return (\r\n    code !== 96 ||\r\n    this.events[this.events.length - 1][1].type === 'characterEscape'\r\n  )\r\n}\r\n\r\nfunction tokenizeCodeText(effects, ok, nok) {\r\n  var sizeOpen = 0\r\n  var size\r\n  var token\r\n  return start\r\n\r\n  function start(code) {\r\n    effects.enter('codeText')\r\n    effects.enter('codeTextSequence')\r\n    return openingSequence(code)\r\n  }\r\n\r\n  function openingSequence(code) {\r\n    if (code === 96) {\r\n      effects.consume(code)\r\n      sizeOpen++\r\n      return openingSequence\r\n    }\r\n\r\n    effects.exit('codeTextSequence')\r\n    return gap(code)\r\n  }\r\n\r\n  function gap(code) {\r\n    // EOF.\r\n    if (code === null) {\r\n      return nok(code)\r\n    } // Closing fence?\r\n    // Could also be data.\r\n\r\n    if (code === 96) {\r\n      token = effects.enter('codeTextSequence')\r\n      size = 0\r\n      return closingSequence(code)\r\n    } // Tabs don’t work, and virtual spaces don’t make sense.\r\n\r\n    if (code === 32) {\r\n      effects.enter('space')\r\n      effects.consume(code)\r\n      effects.exit('space')\r\n      return gap\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter('lineEnding')\r\n      effects.consume(code)\r\n      effects.exit('lineEnding')\r\n      return gap\r\n    } // Data.\r\n\r\n    effects.enter('codeTextData')\r\n    return data(code)\r\n  } // In code.\r\n\r\n  function data(code) {\r\n    if (\r\n      code === null ||\r\n      code === 32 ||\r\n      code === 96 ||\r\n      markdownLineEnding(code)\r\n    ) {\r\n      effects.exit('codeTextData')\r\n      return gap(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return data\r\n  } // Closing fence.\r\n\r\n  function closingSequence(code) {\r\n    // More.\r\n    if (code === 96) {\r\n      effects.consume(code)\r\n      size++\r\n      return closingSequence\r\n    } // Done!\r\n\r\n    if (size === sizeOpen) {\r\n      effects.exit('codeTextSequence')\r\n      effects.exit('codeText')\r\n      return ok(code)\r\n    } // More or less accents: mark as data.\r\n\r\n    token.type = 'codeTextData'\r\n    return data(code)\r\n  }\r\n}\r\n\r\nmodule.exports = codeText\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}