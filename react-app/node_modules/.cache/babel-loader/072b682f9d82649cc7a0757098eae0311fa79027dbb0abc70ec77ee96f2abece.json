{"ast":null,"code":"'use strict';\n\nvar bail = require('bail');\nvar buffer = require('is-buffer');\nvar extend = require('extend');\nvar plain = require('is-plain-obj');\nvar trough = require('trough');\nvar vfile = require('vfile');\n\n// Expose a frozen processor.\nmodule.exports = unified().freeze();\nvar slice = [].slice;\nvar own = {}.hasOwnProperty;\n\n// Process pipeline.\nvar pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file);\n}\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done);\n  function done(error, tree, file) {\n    if (error) {\n      next(error);\n    } else {\n      ctx.tree = tree;\n      ctx.file = file;\n      next();\n    }\n  }\n}\nfunction pipelineStringify(p, ctx) {\n  var result = p.stringify(ctx.tree, ctx.file);\n  if (result === undefined || result === null) {\n    // Empty.\n  } else if (typeof result === 'string' || buffer(result)) {\n    if ('value' in ctx.file) {\n      ctx.file.value = result;\n    }\n    ctx.file.contents = result;\n  } else {\n    ctx.file.result = result;\n  }\n}\n\n// Function to create the first processor.\nfunction unified() {\n  var attachers = [];\n  var transformers = trough();\n  var namespace = {};\n  var freezeIndex = -1;\n  var frozen;\n\n  // Data management.\n  processor.data = data;\n\n  // Lock.\n  processor.freeze = freeze;\n\n  // Plugins.\n  processor.attachers = attachers;\n  processor.use = use;\n\n  // API.\n  processor.parse = parse;\n  processor.stringify = stringify;\n  processor.run = run;\n  processor.runSync = runSync;\n  processor.process = process;\n  processor.processSync = processSync;\n\n  // Expose.\n  return processor;\n\n  // Create a new processor based on the processor in the current scope.\n  function processor() {\n    var destination = unified();\n    var index = -1;\n    while (++index < attachers.length) {\n      destination.use.apply(null, attachers[index]);\n    }\n    destination.data(extend(true, {}, namespace));\n    return destination;\n  }\n\n  // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: it’s frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n  function freeze() {\n    var values;\n    var transformer;\n    if (frozen) {\n      return processor;\n    }\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex];\n      if (values[1] === false) {\n        continue;\n      }\n      if (values[1] === true) {\n        values[1] = undefined;\n      }\n      transformer = values[0].apply(processor, values.slice(1));\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n    frozen = true;\n    freezeIndex = Infinity;\n    return processor;\n  }\n\n  // Data management.\n  // Getter / setter for processor-specific informtion.\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      }\n\n      // Get `key`.\n      return own.call(namespace, key) && namespace[key] || null;\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    }\n\n    // Get space.\n    return namespace;\n  }\n\n  // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n  function use(value) {\n    var settings;\n    assertUnfrozen('use', frozen);\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments);\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`');\n    }\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings);\n    }\n    return processor;\n    function addPreset(result) {\n      addList(result.plugins);\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings);\n      }\n    }\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`');\n      }\n    }\n    function addList(plugins) {\n      var index = -1;\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        while (++index < plugins.length) {\n          add(plugins[index]);\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n    function addPlugin(plugin, value) {\n      var entry = find(plugin);\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(true, entry[1], value);\n        }\n        entry[1] = value;\n      } else {\n        attachers.push(slice.call(arguments));\n      }\n    }\n  }\n  function find(plugin) {\n    var index = -1;\n    while (++index < attachers.length) {\n      if (attachers[index][0] === plugin) {\n        return attachers[index];\n      }\n    }\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n  function parse(doc) {\n    var file = vfile(doc);\n    var Parser;\n    freeze();\n    Parser = processor.Parser;\n    assertParser('parse', Parser);\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse();\n    }\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n  function run(node, file, cb) {\n    assertNode(node);\n    freeze();\n    if (!cb && typeof file === 'function') {\n      cb = file;\n      file = null;\n    }\n    if (!cb) {\n      return new Promise(executor);\n    }\n    executor(null, cb);\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done);\n      function done(error, tree, file) {\n        tree = tree || node;\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          cb(null, tree, file);\n        }\n      }\n    }\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n  function runSync(node, file) {\n    var result;\n    var complete;\n    run(node, file, done);\n    assertDone('runSync', 'run', complete);\n    return result;\n    function done(error, tree) {\n      complete = true;\n      result = tree;\n      bail(error);\n    }\n  }\n\n  // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n  function stringify(node, doc) {\n    var file = vfile(doc);\n    var Compiler;\n    freeze();\n    Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile();\n    }\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n  function process(doc, cb) {\n    freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n    if (!cb) {\n      return new Promise(executor);\n    }\n    executor(null, cb);\n    function executor(resolve, reject) {\n      var file = vfile(doc);\n      pipeline.run(processor, {\n        file: file\n      }, done);\n      function done(error) {\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          cb(null, file);\n        }\n      }\n    }\n  }\n\n  // Process the given document (in string or vfile representation), sync.\n  function processSync(doc) {\n    var file;\n    var complete;\n    freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    file = vfile(doc);\n    process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n    function done(error) {\n      complete = true;\n      bail(error);\n    }\n  }\n}\n\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n  return typeof value === 'function' && value.prototype && (\n  // A function with keys in its prototype is probably a constructor.\n  // Classes’ prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  keys(value.prototype) || name in value.prototype);\n}\n\n// Check if `value` is an object with keys.\nfunction keys(value) {\n  var key;\n  for (key in value) {\n    return true;\n  }\n  return false;\n}\n\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`');\n  }\n}\n\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`');\n  }\n}\n\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.');\n  }\n}\n\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n}\n\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}","map":{"version":3,"names":["bail","require","buffer","extend","plain","trough","vfile","module","exports","unified","freeze","slice","own","hasOwnProperty","pipeline","use","pipelineParse","pipelineRun","pipelineStringify","p","ctx","tree","parse","file","next","run","done","error","result","stringify","undefined","value","contents","attachers","transformers","namespace","freezeIndex","frozen","processor","data","runSync","process","processSync","destination","index","length","apply","values","transformer","Infinity","key","arguments","assertUnfrozen","call","settings","addPlugin","addList","addPreset","Error","plugins","add","plugin","entry","find","push","doc","Parser","assertParser","newable","String","node","cb","assertNode","Promise","executor","resolve","reject","complete","assertDone","Compiler","assertCompiler","compile","name","prototype","keys","type","asyncName"],"sources":["C:/Users/wally/Documents/GitHub/SoftwareDevelopment-Group-E-Project/react-app/node_modules/unified/index.js"],"sourcesContent":["'use strict'\r\n\r\nvar bail = require('bail')\r\nvar buffer = require('is-buffer')\r\nvar extend = require('extend')\r\nvar plain = require('is-plain-obj')\r\nvar trough = require('trough')\r\nvar vfile = require('vfile')\r\n\r\n// Expose a frozen processor.\r\nmodule.exports = unified().freeze()\r\n\r\nvar slice = [].slice\r\nvar own = {}.hasOwnProperty\r\n\r\n// Process pipeline.\r\nvar pipeline = trough()\r\n  .use(pipelineParse)\r\n  .use(pipelineRun)\r\n  .use(pipelineStringify)\r\n\r\nfunction pipelineParse(p, ctx) {\r\n  ctx.tree = p.parse(ctx.file)\r\n}\r\n\r\nfunction pipelineRun(p, ctx, next) {\r\n  p.run(ctx.tree, ctx.file, done)\r\n\r\n  function done(error, tree, file) {\r\n    if (error) {\r\n      next(error)\r\n    } else {\r\n      ctx.tree = tree\r\n      ctx.file = file\r\n      next()\r\n    }\r\n  }\r\n}\r\n\r\nfunction pipelineStringify(p, ctx) {\r\n  var result = p.stringify(ctx.tree, ctx.file)\r\n\r\n  if (result === undefined || result === null) {\r\n    // Empty.\r\n  } else if (typeof result === 'string' || buffer(result)) {\r\n    if ('value' in ctx.file) {\r\n      ctx.file.value = result\r\n    }\r\n\r\n    ctx.file.contents = result\r\n  } else {\r\n    ctx.file.result = result\r\n  }\r\n}\r\n\r\n// Function to create the first processor.\r\nfunction unified() {\r\n  var attachers = []\r\n  var transformers = trough()\r\n  var namespace = {}\r\n  var freezeIndex = -1\r\n  var frozen\r\n\r\n  // Data management.\r\n  processor.data = data\r\n\r\n  // Lock.\r\n  processor.freeze = freeze\r\n\r\n  // Plugins.\r\n  processor.attachers = attachers\r\n  processor.use = use\r\n\r\n  // API.\r\n  processor.parse = parse\r\n  processor.stringify = stringify\r\n  processor.run = run\r\n  processor.runSync = runSync\r\n  processor.process = process\r\n  processor.processSync = processSync\r\n\r\n  // Expose.\r\n  return processor\r\n\r\n  // Create a new processor based on the processor in the current scope.\r\n  function processor() {\r\n    var destination = unified()\r\n    var index = -1\r\n\r\n    while (++index < attachers.length) {\r\n      destination.use.apply(null, attachers[index])\r\n    }\r\n\r\n    destination.data(extend(true, {}, namespace))\r\n\r\n    return destination\r\n  }\r\n\r\n  // Freeze: used to signal a processor that has finished configuration.\r\n  //\r\n  // For example, take unified itself: it’s frozen.\r\n  // Plugins should not be added to it.\r\n  // Rather, it should be extended, by invoking it, before modifying it.\r\n  //\r\n  // In essence, always invoke this when exporting a processor.\r\n  function freeze() {\r\n    var values\r\n    var transformer\r\n\r\n    if (frozen) {\r\n      return processor\r\n    }\r\n\r\n    while (++freezeIndex < attachers.length) {\r\n      values = attachers[freezeIndex]\r\n\r\n      if (values[1] === false) {\r\n        continue\r\n      }\r\n\r\n      if (values[1] === true) {\r\n        values[1] = undefined\r\n      }\r\n\r\n      transformer = values[0].apply(processor, values.slice(1))\r\n\r\n      if (typeof transformer === 'function') {\r\n        transformers.use(transformer)\r\n      }\r\n    }\r\n\r\n    frozen = true\r\n    freezeIndex = Infinity\r\n\r\n    return processor\r\n  }\r\n\r\n  // Data management.\r\n  // Getter / setter for processor-specific informtion.\r\n  function data(key, value) {\r\n    if (typeof key === 'string') {\r\n      // Set `key`.\r\n      if (arguments.length === 2) {\r\n        assertUnfrozen('data', frozen)\r\n        namespace[key] = value\r\n        return processor\r\n      }\r\n\r\n      // Get `key`.\r\n      return (own.call(namespace, key) && namespace[key]) || null\r\n    }\r\n\r\n    // Set space.\r\n    if (key) {\r\n      assertUnfrozen('data', frozen)\r\n      namespace = key\r\n      return processor\r\n    }\r\n\r\n    // Get space.\r\n    return namespace\r\n  }\r\n\r\n  // Plugin management.\r\n  //\r\n  // Pass it:\r\n  // *   an attacher and options,\r\n  // *   a preset,\r\n  // *   a list of presets, attachers, and arguments (list of attachers and\r\n  //     options).\r\n  function use(value) {\r\n    var settings\r\n\r\n    assertUnfrozen('use', frozen)\r\n\r\n    if (value === null || value === undefined) {\r\n      // Empty.\r\n    } else if (typeof value === 'function') {\r\n      addPlugin.apply(null, arguments)\r\n    } else if (typeof value === 'object') {\r\n      if ('length' in value) {\r\n        addList(value)\r\n      } else {\r\n        addPreset(value)\r\n      }\r\n    } else {\r\n      throw new Error('Expected usable value, not `' + value + '`')\r\n    }\r\n\r\n    if (settings) {\r\n      namespace.settings = extend(namespace.settings || {}, settings)\r\n    }\r\n\r\n    return processor\r\n\r\n    function addPreset(result) {\r\n      addList(result.plugins)\r\n\r\n      if (result.settings) {\r\n        settings = extend(settings || {}, result.settings)\r\n      }\r\n    }\r\n\r\n    function add(value) {\r\n      if (typeof value === 'function') {\r\n        addPlugin(value)\r\n      } else if (typeof value === 'object') {\r\n        if ('length' in value) {\r\n          addPlugin.apply(null, value)\r\n        } else {\r\n          addPreset(value)\r\n        }\r\n      } else {\r\n        throw new Error('Expected usable value, not `' + value + '`')\r\n      }\r\n    }\r\n\r\n    function addList(plugins) {\r\n      var index = -1\r\n\r\n      if (plugins === null || plugins === undefined) {\r\n        // Empty.\r\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\r\n        while (++index < plugins.length) {\r\n          add(plugins[index])\r\n        }\r\n      } else {\r\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\r\n      }\r\n    }\r\n\r\n    function addPlugin(plugin, value) {\r\n      var entry = find(plugin)\r\n\r\n      if (entry) {\r\n        if (plain(entry[1]) && plain(value)) {\r\n          value = extend(true, entry[1], value)\r\n        }\r\n\r\n        entry[1] = value\r\n      } else {\r\n        attachers.push(slice.call(arguments))\r\n      }\r\n    }\r\n  }\r\n\r\n  function find(plugin) {\r\n    var index = -1\r\n\r\n    while (++index < attachers.length) {\r\n      if (attachers[index][0] === plugin) {\r\n        return attachers[index]\r\n      }\r\n    }\r\n  }\r\n\r\n  // Parse a file (in string or vfile representation) into a unist node using\r\n  // the `Parser` on the processor.\r\n  function parse(doc) {\r\n    var file = vfile(doc)\r\n    var Parser\r\n\r\n    freeze()\r\n    Parser = processor.Parser\r\n    assertParser('parse', Parser)\r\n\r\n    if (newable(Parser, 'parse')) {\r\n      return new Parser(String(file), file).parse()\r\n    }\r\n\r\n    return Parser(String(file), file) // eslint-disable-line new-cap\r\n  }\r\n\r\n  // Run transforms on a unist node representation of a file (in string or\r\n  // vfile representation), async.\r\n  function run(node, file, cb) {\r\n    assertNode(node)\r\n    freeze()\r\n\r\n    if (!cb && typeof file === 'function') {\r\n      cb = file\r\n      file = null\r\n    }\r\n\r\n    if (!cb) {\r\n      return new Promise(executor)\r\n    }\r\n\r\n    executor(null, cb)\r\n\r\n    function executor(resolve, reject) {\r\n      transformers.run(node, vfile(file), done)\r\n\r\n      function done(error, tree, file) {\r\n        tree = tree || node\r\n        if (error) {\r\n          reject(error)\r\n        } else if (resolve) {\r\n          resolve(tree)\r\n        } else {\r\n          cb(null, tree, file)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Run transforms on a unist node representation of a file (in string or\r\n  // vfile representation), sync.\r\n  function runSync(node, file) {\r\n    var result\r\n    var complete\r\n\r\n    run(node, file, done)\r\n\r\n    assertDone('runSync', 'run', complete)\r\n\r\n    return result\r\n\r\n    function done(error, tree) {\r\n      complete = true\r\n      result = tree\r\n      bail(error)\r\n    }\r\n  }\r\n\r\n  // Stringify a unist node representation of a file (in string or vfile\r\n  // representation) into a string using the `Compiler` on the processor.\r\n  function stringify(node, doc) {\r\n    var file = vfile(doc)\r\n    var Compiler\r\n\r\n    freeze()\r\n    Compiler = processor.Compiler\r\n    assertCompiler('stringify', Compiler)\r\n    assertNode(node)\r\n\r\n    if (newable(Compiler, 'compile')) {\r\n      return new Compiler(node, file).compile()\r\n    }\r\n\r\n    return Compiler(node, file) // eslint-disable-line new-cap\r\n  }\r\n\r\n  // Parse a file (in string or vfile representation) into a unist node using\r\n  // the `Parser` on the processor, then run transforms on that node, and\r\n  // compile the resulting node using the `Compiler` on the processor, and\r\n  // store that result on the vfile.\r\n  function process(doc, cb) {\r\n    freeze()\r\n    assertParser('process', processor.Parser)\r\n    assertCompiler('process', processor.Compiler)\r\n\r\n    if (!cb) {\r\n      return new Promise(executor)\r\n    }\r\n\r\n    executor(null, cb)\r\n\r\n    function executor(resolve, reject) {\r\n      var file = vfile(doc)\r\n\r\n      pipeline.run(processor, {file: file}, done)\r\n\r\n      function done(error) {\r\n        if (error) {\r\n          reject(error)\r\n        } else if (resolve) {\r\n          resolve(file)\r\n        } else {\r\n          cb(null, file)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Process the given document (in string or vfile representation), sync.\r\n  function processSync(doc) {\r\n    var file\r\n    var complete\r\n\r\n    freeze()\r\n    assertParser('processSync', processor.Parser)\r\n    assertCompiler('processSync', processor.Compiler)\r\n    file = vfile(doc)\r\n\r\n    process(file, done)\r\n\r\n    assertDone('processSync', 'process', complete)\r\n\r\n    return file\r\n\r\n    function done(error) {\r\n      complete = true\r\n      bail(error)\r\n    }\r\n  }\r\n}\r\n\r\n// Check if `value` is a constructor.\r\nfunction newable(value, name) {\r\n  return (\r\n    typeof value === 'function' &&\r\n    value.prototype &&\r\n    // A function with keys in its prototype is probably a constructor.\r\n    // Classes’ prototype methods are not enumerable, so we check if some value\r\n    // exists in the prototype.\r\n    (keys(value.prototype) || name in value.prototype)\r\n  )\r\n}\r\n\r\n// Check if `value` is an object with keys.\r\nfunction keys(value) {\r\n  var key\r\n  for (key in value) {\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n// Assert a parser is available.\r\nfunction assertParser(name, Parser) {\r\n  if (typeof Parser !== 'function') {\r\n    throw new Error('Cannot `' + name + '` without `Parser`')\r\n  }\r\n}\r\n\r\n// Assert a compiler is available.\r\nfunction assertCompiler(name, Compiler) {\r\n  if (typeof Compiler !== 'function') {\r\n    throw new Error('Cannot `' + name + '` without `Compiler`')\r\n  }\r\n}\r\n\r\n// Assert the processor is not frozen.\r\nfunction assertUnfrozen(name, frozen) {\r\n  if (frozen) {\r\n    throw new Error(\r\n      'Cannot invoke `' +\r\n        name +\r\n        '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'\r\n    )\r\n  }\r\n}\r\n\r\n// Assert `node` is a unist node.\r\nfunction assertNode(node) {\r\n  if (!node || typeof node.type !== 'string') {\r\n    throw new Error('Expected node, got `' + node + '`')\r\n  }\r\n}\r\n\r\n// Assert that `complete` is `true`.\r\nfunction assertDone(name, asyncName, complete) {\r\n  if (!complete) {\r\n    throw new Error(\r\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\r\n    )\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}